<?php

// Generated by Haxe 3.3.0
class Reflect {
	public function __construct(){}
	static function field($o, $field) {
		return _hx_field($o, $field);
	}
	static function getProperty($o, $field) {
		if(null === $o) {
			return null;
		}
		$cls = null;
		$tmp = Std::is($o, _hx_qtype("Class"));
		if($tmp) {
			$cls = $o->__tname__;
		} else {
			$cls = get_class($o);
		}
		$cls_vars = get_class_vars($cls);
		$tmp1 = isset($cls_vars['__properties__']) && isset($cls_vars['__properties__']['get_'.$field]) && ($field = $cls_vars['__properties__']['get_'.$field]);
		if($tmp1) {
			return $o->$field();
		} else {
			return _hx_field($o, $field);
		}
	}
	static function fields($o) {
		if($o === null) {
			return new _hx_array(array());
		}
		$tmp = $o instanceof _hx_array;
		if($tmp) {
			return new _hx_array(array('concat','copy','insert','iterator','length','join','pop','push','remove','reverse','shift','slice','sort','splice','toString','unshift'));
		} else {
			$tmp1 = is_string($o);
			if($tmp1) {
				return new _hx_array(array('charAt','charCodeAt','indexOf','lastIndexOf','length','split','substr','toLowerCase','toString','toUpperCase'));
			} else {
				return new _hx_array(_hx_get_object_vars($o));
			}
		}
	}
	static function isFunction($f) {
		$tmp = !(is_array($f) && is_callable($f)) || _hx_is_lambda($f);
		if($tmp) {
			$tmp1 = null;
			$tmp2 = is_array($f);
			if($tmp2) {
				$o = $f[0];
				$field = $f[1];
				$tmp1 = _hx_has_field($o, $field);
			} else {
				$tmp1 = false;
			}
			if($tmp1) {
				$tmp3 = $f[1];
				return $tmp3 !== "length";
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	function __toString() { return 'Reflect'; }
}
